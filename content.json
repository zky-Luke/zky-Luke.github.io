[{"title":"SSH Git多账号配置 一分钟上手","date":"2019-03-06T11:40:17.000Z","path":"2019/03/06/Article1/","text":"使用介绍默认情况下，一台电脑只有一个SSH Key，假如我们有多个Github账号，需要将代码迁移账号，这时候这篇文章就派上用场啦~ 简单上手一、生成秘钥公钥装好Git后，桌面右键点击Git Bash进入Git界面，输入以下命令：12345//切换到ssh目录cd ~/.ssh//新建两个账户的ssh-keyssh-keygen -t rsa -C 10000@qq.comssh-keygen -t rsa -C 20000@qq.com 1.png 2.png 上面先填写Git账户的ssh-key的名称（默认是id_rsa）,下一步则是填写密码及确认密码，不需要密码的话可以直接回车即可。在ssh文件夹已经生成文件，如下 3.png 二、查看秘钥并放到Github账户123// 查看秘钥cat id_rsa_test.pubcat id_rsa_test2.pub 4.png 分别添加到两个github账户，详细步骤百度大大搜一搜哈 三、在ssh目录下创建config并配置123456// 创建configtouch config// 查看当前目录ls// 编辑configvim config 5.png 12345678910111213# 配置github.comHost github.com // 自定义域名地址 HostName github.com // 真实域名地址 IdentityFile C:\\Users\\Admin\\.ssh\\id_rsa_test // id_rsa位置 PreferredAuthentications publickey // 权限验证 User username1 // 用户名# 配置git.github2.com Host github2.com HostName github.com IdentityFile C:\\Users\\Admin\\.ssh\\id_rsa_test2 PreferredAuthentications publickey User username2 写入如上配置，域名和id_rsa位置要根据实际情况填写，然后保存即可。 四、测试是否配置成功123// 测试配置ssh -T git@github.comssh -T git@github2.com 6.png 7.png 出现上图所示，则表示成功啦~~ 项目迁移假如有个旧账号的项目要迁移到新账号，先把旧账号项目的代码克隆下来，在新账号新建个项目，在cmd添加远程仓库的ssh并命名为origin2,使用如下命令强制提交代码，就ok了，好嗨~1git push -u origin2 master -f 8.png","tags":[{"name":"SSH","slug":"SSH","permalink":"https://zky-luke.github.io/tags/SSH/"},{"name":"Git","slug":"Git","permalink":"https://zky-luke.github.io/tags/Git/"}]},{"title":"puppeteer新手入门(chromium下载跳坑)","date":"2017-12-27T11:44:55.000Z","path":"2017/12/27/Article2/","text":"puppeteer简介puppeteer 翻译是操纵木偶的人，利用这个工具，我们能做一个操纵页面的人。puppeteer是一个nodejs的库，支持调用Chrome的API来操纵Web，相比较Selenium或是PhantomJs,它最大的特点就是它的操作Dom可以完全在内存中进行模拟既在V8引擎中处理而不打开浏览器，而且关键是这个是Chrome团队在维护，会拥有更好的兼容性和前景。 puppeteer功能 生成页面的截图和PDF。 抓取SPA并生成预先呈现的内容（即“SSR”）。 从网站抓取你需要的内容。 自动表单提交，UI测试，键盘输入等 创建一个最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。 捕获您的网站的时间线跟踪，以帮助诊断性能问题。 puppeteer轻松入门1、环境和安装Puppeteer 至少需要 Node v6.4.0，如要使用 async / await，只有 Node v7.6.0 或更高版本才支持。 node下载地址： https://nodejs.org/zh-cn/ 2、创建项目2.1、创建test目录，进入目录执行npm init2.2、安装 puppeteer1yarn add puppeteer 或者 npm i puppeteer 可能会出现以下报错:12ERROR: Failed to download Chromium r515411! Set &quot;PUPPETEER_SKIP_CHROMIUM_DOWNLOAD&quot; env variable to skip download. 是因为在执行安装的过程中需要执行install.js，这里会下载Chromium,官网建议是进行跳过，我们可以执行 —ignore-scripts 忽略这个js执行。也可以通过设置环境变量set PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1阻止下载 Chromium （因为封网，直接下载会失败） 1npm i --save puppeteer --ignore-scripts 2.3、手动下载Chromium下载地址：https://download-chromium.appspot.com/ (打开蓝灯翻墙软件…) 把下载刚刚下载的文件解压出来会有chrome-win32文件夹，把里面的文件拷贝到项目新建的chromium文件夹中 2.4、新建index.js（截图功能）, 代码如下：123456789const puppeteer = require(&apos;puppeteer&apos;);(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&apos;https://y.qq.com&apos;); await page.screenshot(&#123;path: &apos;yqq.png&apos;&#125;); browser.close();&#125;)(); 打开cmd执行index.js1node index.js 这时候可能出现以下错误：123456(node:8672) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): AssertionError [ERR_ASSERTION]: Chromium revision is not downloaded. Run &quot;npm install&quot;(node:8672) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. 显示chromium 未下载错误，因为chromium默认的下载路径是在node_modules/puppeteer/.local-chromium/目录，这时候我们的chromium是在项目根目录，所以需要配置指定路径，修改index.js文件()：123456789101112const puppeteer = require(&apos;puppeteer&apos;);(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; executablePath: &apos;./chromium/chrome.exe&apos;, headless: false &#125;); const page = await browser.newPage(); await page.goto(&apos;http://music.163.com/&apos;); await page.screenshot(&#123;path: &apos;music.png&apos;&#125;); browser.close();&#125;)(); puppeteer launch参数说明： executablePath： 运行Chromium或Chrome可执行文件的路径 headless： 是否运行在浏览器headless模式，true为不打开浏览器执行，默认为true timeout： 等待浏览器实例启动的最长时间（以毫秒为单位）。默认为30000（30秒）。通过0禁用超时 args： 传递给浏览器实例的其他参数 更多参数请参照官网，再次执行index.js可能出现以下错误：1Error: Protocol error (Page.getFrameTree): &apos;Page.getFrameTree&apos; wasn &apos;t found undefined 刚开始找了好久没找到答案，然后上万能的Google找了下，发现了类似的问题 1.png 可能是chromium的版本存在差异，然后重新在chromium官网下载最新版本解压到项目（要注意下相应系统chromium） 执行index.js， 脚本运行chromium浏览器跳转到界面，截图保存到项目中，这样就成功了… 2.5、puppeteer相关地址puppeteer神器官方文档，可以进行其他强大的功能开发…","tags":[{"name":"Puppeteer","slug":"Puppeteer","permalink":"https://zky-luke.github.io/tags/Puppeteer/"},{"name":"Chromium","slug":"Chromium","permalink":"https://zky-luke.github.io/tags/Chromium/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://zky-luke.github.io/tags/NodeJS/"}]},{"title":"构建自己的npm包 简单实现","date":"2017-07-28T11:45:50.000Z","path":"2017/07/28/Article4/","text":"NPM 使用介绍NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 NPM 包构建1、创建demo目录，新建index.js文件index.js文件示例：123module.exports.sayHello = function()&#123; return &quot;Hello World!&quot;;&#125; 2、在项目中引导创建一个package.json文件1npm init 快速创建可以使用npm init -y命令 注册npm账号1、要发布npm包当然需要在npm官网注册一个属于自己的账号npm官网地址： https://www.npmjs.com 2、在cmd中登录账号注册成功后，打开cmd进入到demo目录，登录账号：1npm login 输入用户密码以及邮箱，登录成功后可以输入查询命令：1npm whoami 就能看到你酷酷的账号名了~~ 附：刚注册完有段时间可以发布npm包，过段时间需要邮箱验证通过才能发布包，不然会报错（无伤大雅~~） 上传npm包1、cmd进到demo目录，输入如下命令：npm publish 这时候npm报错大军要来了npm ERR! publish Failed PUT 403npm ERR! code E403npm ERR! you do not have permission to publish &quot;demo&quot;. Are you logged in as the correct user? : demo 这是什么原因？？就是与npm仓库的包名重复了 改改改~~拿出package.json文件，把name字段值改成下面：&quot;name&quot;: &quot;testfun&quot; 注意你的name字段值不要跟我一样，不然还会包上述错误，避免相同包名就可以啦还有一点要注意的是npm对包名的限制：不能有大写字母/空格/下滑线 上传成功后你就可以在npm官网看到： npm包管理1、管理npm包权限123456查看模块拥有者 $ npm owner ls &lt;package_name&gt; 添加发布者 $ npm owner add &lt;user&gt; &lt;package_name&gt; 删除发布者 $ npm owner rm &lt;user&gt; &lt;package_name&gt; 2、撤销发布包( 在项目目录下执行 )1npm unpublish --force 主要是处于安全性考虑，在Azer NPM 撤包事件后，npm公布了一版新的规则，如下： 版本更新少于24小时的包允许下架； 超过24小时的包的下架需要联系npm维护者； 如果有npm维护者参与，npm将检查是否有其他包依赖该包，如果有则不允下架； 如果某个包的所有版本都被移除，npm会上传一个空的占位包，以防后来的使用者不小心引用怀有恶意的替代者。 3、npm的版本控制123npm version patchnpm version minornpm version major 例如：我原本的项目是1.0.0版本的话若是1中情况，变为1.0.1若是2中情况，变为1.1.0若是3中情况，变为2.0.0 不过也可以在package.json中的version更改~~ 使用npm包1、创建test目录，在目录中新建index.js及package.json文件index.js文件代码:12var testfun = require(&quot;testfun&quot;);console.log(testfun.sayHello()); 2、安装testfun包1npm install --save-dev testfun 3、在项目目录中cmd输入1node index.js 就可以看到下面的效果啦~ 这是运行在node环境，那么像运行在浏览器该怎么弄呢~~这时候就要用到browserify了 扩展1、Browserify简介Browserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 Javascript 可以直接使用 Node NPM 安装的一些库。 Browserify是如何工作的 Browserify从你给你的入口文件开始,寻找所有调用require()方法的地方, 然后沿着抽象语法树,通过 detective 模块来找到所有请求的模块. 每一个require()调用里都传入一个字符串作为参数,browserify把这个字符串解析成文件的路径然后递归的查找文件直到整个依赖树都被找到. 每个被require()的文件,它的名字都会被映射到内部的id,最后被整合到一个javascript文件中. 运用到项目 全局安装browserify 1npm install -g browserify 使用browserify 1browserify index.js &gt; bundle.js 在test目录新建index.html,引入以下js文件:1&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 打开index.html就可以看到控制器中的效果啦，这样就用有自己的npm包了(＾ω＾)~~","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://zky-luke.github.io/tags/NodeJS/"},{"name":"NPM","slug":"NPM","permalink":"https://zky-luke.github.io/tags/NPM/"}]},{"title":"Electron 快速入门及打包","date":"2017-07-26T11:45:26.000Z","path":"2017/07/26/Article3/","text":"一、初步理解简介Electron 可以让你使用纯 JavaScript 调用丰富的原生 APIs 来创造桌面应用。你可以把它看作是专注于桌面应用而不是 web 服务器的，io.js 的一个变体。这不意味着 Electron 是绑定了 GUI 库的 JavaScript。相反，Electron 使用 web 页面作为它的 GUI，所以你能把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。 主进程在 Electron 里，运行 package.json 里 main 脚本的进程被称为主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI。 渲染进程由于 Electron 使用 Chromium 来展示页面，所以 Chromium 的多进程结构也被充分利用。每个 Electron 的页面都在运行着自己的进程，这样的进程我们称之为渲染进程。在一般浏览器中，网页通常会在沙盒环境下运行，并且不允许访问原生资源。然而，Electron 用户拥有在网页中调用 io.js 的 APIs 的能力，可以与底层操作系统直接交互。 主进程与渲染进程的区别主进程使用 BrowserWindow 实例创建网页。每个 BrowserWindow 实例都在自己的渲染进程里运行着一个网页。当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的网页。由于在网页里管理原生 GUI 资源是非常危险而且容易造成资源泄露，所以在网页面调用 GUI 相关的 APIs 是不被允许的。如果你想在网页里使用 GUI 操作，其对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。在 Electron，我们提供用于在主进程与渲染进程之间通讯的 ipc 模块。并且也有一个远程进程调用风格的通讯模块 remote。 二、创建 Electron 应用目录结构12345app/├── package.json //配置声明文件├── main.js //主进程渲染文件├── renderer.js //渲染进程文件└── index.html //主入口文件 1.1 创建app目录，在目录中新建index.html及main.js文件（暂时不考虑renderer.js）index.html文件示例：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;!-- All of the Node.js APIs are available in this renderer process. --&gt; We are using Node.js &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;, Chromium &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;, and Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;. &lt;/body&gt; &lt;script&gt; //require(&apos;./renderer.js&apos;) &lt;/script&gt;&lt;/html&gt; main.js文件示例：12345678910111213141516171819202122232425262728293031323334353637383940// var app = require(&apos;app&apos;); // 控制应用生命周期的模块。// var BrowserWindow = require(&apos;browser-window&apos;); // 创建原生浏览器窗口的模块const electron = require(&apos;electron&apos;);const app = electron.app;const BrowserWindow = electron.BrowserWindow;// 保持一个对于 window 对象的全局引用，不然，当 JavaScript 被 GC，// window 会被自动地关闭var mainWindow = null;// 当所有窗口被关闭了，退出。app.on(&apos;window-all-closed&apos;, function() &#123; // 在 OS X 上，通常用户在明确地按下 Cmd + Q 之前 // 应用会保持活动状态 if (process.platform != &apos;darwin&apos;) &#123; app.quit(); &#125;&#125;);// 当 Electron 完成了初始化并且准备创建浏览器窗口的时候// 这个方法就被调用app.on(&apos;ready&apos;, function() &#123; // 创建浏览器窗口。 mainWindow = new BrowserWindow(&#123;width: 800, height: 600&#125;); // 加载应用的 index.html mainWindow.loadURL(&apos;file://&apos; + __dirname + &apos;/index.html&apos;); // 打开开发工具 mainWindow.openDevTools(); // 当 window 被关闭，这个事件会被发出 mainWindow.on(&apos;closed&apos;, function() &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 但这次不是。 mainWindow = null; &#125;);&#125;); 1.2 创建配置文件package.json ( npm init -y ) package.json的格式和 Node 的完全一致，并且那个被 main 字段声明的脚本文件是你的应用的启动脚本，它运行在主进程上。你应用里的 package.json 看起来应该像： 12345&#123; &quot;name&quot; : &quot;app&quot;, &quot;version&quot; : &quot;1.0.1&quot;, &quot;main&quot; : &quot;main.js&quot;&#125; 三、运行 Electron 应用安装electron-prebuilt运行项目1npm install electron-prebuilt -save 你只需要按照如下方式直接运行你的应用1electron . 程序执行成功了… 1.png 四、Electron 应用打包安装electron-packager1npm install electron-packager --save-dev 安装后可以在package.json中看到:123&quot;devDependencies&quot;: &#123; &quot;electron-packager&quot;: &quot;^8.7.2&quot;&#125; 打包阶段（有两种方法）1.1 直接用命令打包1electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt; &lt;optional options&gt; 命令说明： location of project：项目所在路径 name of project：打包的项目名字 platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux） architecture：决定了使用 x86 还是 x64 还是两个架构都用 electron version：electron 的版本 optional options：可选选项 命令比较长，每次要是都用这个命令来打包会很烦，可以使用第二种方法； 1.2 首先在项目根目录下面的 package.json的scripts 下添加代码1&quot;packager&quot;: &quot;electron-packager ./ HelloWorld --all --out ./outApp --version 1.4.0 --overwrite --icon=./app/img/icon/icon.ico&quot; –all 可以换成 –platform=win32 –arch=ia32 platform 是发布平台 win32指windows平台 linux darwin arch=ia32 指32位windows 64位的则为x64 在项目中新建outApp目录1234567app/├── package.json ├── node_modules ├── outApp ├── main.js ├── renderer.js └── index.html 使用命令 npm run-script packager1npm run-script packager 打包命令执行后，可能会遇到如下问题： Packaging app for platform win32 ia32 using electron v1.0.1Downloading tmp-1156-0-electron-v1.0.1-win32-x64.zipError: connect ETIMEDOUT 52.216.0.16:443connect ETIMEDOUT 52.216.0.16:443 这时候需要做的是翻墙（打开蓝灯翻墙软件），多执行几次npm run-script packager，就可以成功了 成功截图如下： 2.png 打包成功啦~~ github源码地址：https://github.com/zky-Luke/electron","tags":[{"name":"Electron","slug":"Electron","permalink":"https://zky-luke.github.io/tags/Electron/"}]}]